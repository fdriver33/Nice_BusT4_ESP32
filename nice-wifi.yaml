# Sends packets via UART to the Nice BUS T4 bus

esphome:
  name: "nice-wifi"
#  name_add_mac_suffix: true
#  platform:
esp8266:
  board: d1_mini

external_components:
  - source:
      type: git
      url: https://github.com/fdriver33/Nice_BusT4_ESP32
    refresh: 0s
#  - source: my_components

# Enable logging
logger:
  level: DEBUG
  baud_rate: 0

# Enable Home Assistant API
api:
  reboot_timeout: 0s # otherwise it reboots when disconnected from hassio

  services:
  # to send hex commands to the drive
  - service: raw_command
    variables:
        raw_cmd: string
    then:
      lambda: |-
         nice_cover -> NiceBusT4::send_raw_cmd(raw_cmd);

  - service: send_inf_command
    variables:
       to_addr: string
       whose: string
       command: string
       type_command: string
       next_data: string
       data_on: bool
       data_command: string
    then:
      lambda: |-
        nice_cover -> NiceBusT4::send_inf_cmd(to_addr, whose, command, type_command, next_data, data_on, data_command);

  # leaf length recognition (gate panel length)
  - service: gate_length_recognition
    then:
      lambda: |-
         nice_cover -> NiceBusT4::set_mcu("0b","01");

  # BlueBus devices recognition
  - service: devices_recognition
    then:
      lambda: |-
         nice_cover -> NiceBusT4::set_mcu("0a","01");

  # closing force
  - service: closing_force
    variables:
      force: string
    then:
      lambda: |-
         nice_cover -> NiceBusT4::set_mcu("4b", force);

  # opening force
  - service: opening_force
    variables:
      force: string
    then:
      lambda: |-
         nice_cover -> NiceBusT4::set_mcu("4a", force);

ota:
  - platform: esphome

# Set status LED for Wemos D1 mini
status_led:
  pin:
    number: D4
    inverted: true

wifi:
  ssid: !secret wifi_ssid
  password:  !secret wifi_password

  # Enable fallback hotspot (captive portal) in case Wi-Fi connection fails
  ap:
    password: ""

captive_portal:

web_server:
  port: 80
#  js_include: "www.js"
#  js_url: ""
#  version: 2

# Buttons for sending commands
button:
  - platform: template
    name: Step-by-step
    id: sbs
    on_press:
      lambda: |-
           nice_cover -> NiceBusT4::send_cmd(bus_t4::SBS);

  - platform: template
    name: Inputs status
    id: in_stat
    on_press:
      lambda: |-
           nice_cover -> NiceBusT4::send_raw_cmd("55.0D.00.03.00.66.08.06.6B.04.D0.99.00.00.4D.0D");

  # 55.0E.00.03.00.81.08.07.8D.04.0B.A9.00.01.01.A6.0E position search

  - platform: template
    name: Partial open 1
    id: p_opn1
    on_press:
      lambda: |-
         nice_cover -> NiceBusT4::send_cmd(bus_t4::P_OPN1);

cover:
- platform: bus_t4
  name: "Nice Cover"
  device_class: gate
  id: nice_cover

#  address: 0x0003            # drive address
#  use_address: 0x0081        # gateway address

# Working with the OXI receiver

# Disable auto-closing if needed for loading/unloading work
switch:
  - platform: template
    name: "Auto-closing"
    id: autoclose
    restore_mode: DISABLED
#    optimistic: true
    lambda: |-
      if (nice_cover -> NiceBusT4::autocls_flag) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      lambda: |-
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "80", "a9", "00", true, "01");
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "84", "a9", "00", true, "01");
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "80", "99", "00", true, "01");
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "84", "99", "00", true, "01");
    turn_off_action:
      lambda: |-
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "80", "a9", "00", true, "00");
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "84", "a9", "00", true, "00");
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "80", "99", "00", true, "01");
        nice_cover -> NiceBusT4::send_inf_cmd("0003", "04", "84", "99", "00", true, "01");

#script:
#  - id: send_cmd
#    then:
#      - switch.turn_on: my_switch
#      - delay: 1s
#      - switch.turn_off: my_switch
